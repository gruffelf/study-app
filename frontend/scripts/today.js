// Script used by the today page, getting the tasks for the current day and the pomodoro timer

// Gets references to html elements
taskContainer = document.getElementById("task-container");
timer = document.getElementById("timer");

// Function to add task to html used by loadTasks()
function addTask(name, category, description, date, subject, id, day) {
  // If task is a study tasks
  if (category == "study") {
    // Tasks display without due date
    taskHTML = `
      <div class="task" data-name="${name}" data-category="${category}" data-id="${id}" id="${id}">
        <div class="task-data">
        <span><input onclick="taskCheckbox(event)" class="task-checkbox" type="checkbox" style="margin-right: 0.5rem"><span class="task-name">${name}</span></span>
            <span style="font-weight: normal; font-size: 0.9rem; font-style: italic">${description}</span>
            <span class="task-subject">From ${subject}</span>
        </div>
      </div>`;
    taskContainer.innerHTML += taskHTML;

    // If task is a assessment tasks
  } else {
    // Tasks display with due date, generated by finding the difference between today and the due date in milliseconds and converting it to days
    taskHTML = `
      <div class="task" data-name="${name}" data-category="${category}" data-id="${id}" id="${id}">

        <div class="task-data">
            <span><input onclick="taskCheckbox(event)" class="task-checkbox" type="checkbox" style="margin-right: 0.5rem"><span class="task-name">Continue "${name}"</span></span>
            <span style="font-weight: normal; font-size: 0.9rem; font-style: italic">${description}</span>
            <span class="task-subject">From ${subject}</span>
            <span class="task-subject">Due in <span style="font-weight:bold">${Math.round((date - Date.now()) / 86400000)}</span> days</span>
        </div>
      </div>`;
    taskContainer.innerHTML += taskHTML;
  }
}

// Onclick event for checkmark on tasks. Simply changes the style of the task element
function taskCheckbox(e) {
  const task = e.target.closest(".task");

  if (e.target.checked == true) {
    task.style.backgroundColor = "lightgreen";
  } else {
    task.style.backgroundColor = "white";
  }
}

// Load tasks with addTask() from the api database
async function loadTasks() {
  get_header(
    "tasks",
    JSON.stringify([0, "all", currentDay]),
    currentToken,
  ).then((data) => {
    data = JSON.parse(data);

    data.forEach((value) => {
      addTask(
        value["name"],
        value["category"],
        value["description"],
        new Date(value["date"]),
        value["subject"],
        value["id"],
        value["day"],
      );
    });
  });
}

// Initalises global variables and html references to be used by pomodoro timer
timerInterval = null;
circle = null;
maxSeconds = 10;
seconds = 0;
timerButton = document.getElementById("timer-button");
pauseButton = document.getElementById("pause-button");
times = ["study", "short", "study", "short", "study", "short", "study", "long"]; // Establishes order of stages, so it can be increment numerically to get the list
stages = document.getElementsByClassName("stage");
currentStage = 0;
timeLengths = { study: 25, short: 5, long: 30 }; // Establishes lengths of each pomodoro stage
firstClick = false;
isPaused = false;

// To be run in an interval every second, moving the timer to the percentage of timer that has passed
// And setting the display to a formatted MM:SS of the remaining time round to the second
function timerTick() {
  circle.animate(seconds / maxSeconds);
  currentTime = maxSeconds - seconds;
  minutes = Math.floor(currentTime / 60);
  circle.setText(
    `${minutes.toLocaleString(undefined, { minimumIntegerDigits: 2 })}:${(currentTime - 60 * minutes).toLocaleString(undefined, { minimumIntegerDigits: 2 })}`,
  );
}

// Run when timer runs out of time, or is reset. Hides the pause button, resets progress bar and clears interval and updates text
function stopTimer() {
  pauseButton.classList.add("hide");
  circle.stop();
  circle.set(1);
  clearInterval(timerInterval);
  timerInterval = null;
  seconds = 0;
  timerButton.textContent = "Start Session";
}

// Run whenever start/reset timer button is pressed
function startTimer(e) {
  isPaused = false;
  pauseButton.classList.remove("hide");

  // If timer is not running, then start timer
  if (!timerInterval) {
    if (firstClick) {
      nextStage();
    } else {
      firstClick = true;
    }

    // Calculates total seconds based off of times object
    maxSeconds = timeLengths[times[currentStage]] * 60;

    // Initlises timer
    timerButton.textContent = "Skip Session";
    circle.set(0);
    timerTick();

    // Starts interval to run every second
    timerInterval = setInterval(() => {
      timerTick();

      if (seconds > maxSeconds) {
        circle.setText("Times up. Ready to Continue?");
        stopTimer();
      } else {
        seconds += 1;
      }
    }, 1000);

    // If timer is running, then reset timer
  } else {
    circle.setText("Ready to Start");
    stopTimer();
    firstClick = false;
    nextStage();
  }
}

// Run whenever pause/resume button is pressed
function pauseTimer(e) {
  // If timer is currently pause
  if (isPaused) {
    // Resume timer
    isPaused = false;
    pauseButton.textContent = "Pause Timer";

    // Reinitalise interval
    timerInterval = setInterval(() => {
      timerTick();

      if (seconds > maxSeconds) {
        circle.setText("Times up. Ready to Continue?");
        stopTimer();
      } else {
        seconds += 1;
      }
    }, 1000);

    // If timer is currently running
  } else {
    //Pause Timer
    isPaused = true;
    pauseButton.textContent = "Resume Timer";

    // Pause interval
    clearInterval(timerInterval);
  }
}

// Match each stage with its class for when its active
stageClasses = { study: "studying", short: "shorting", long: "longing" };

// Runs when it needs to progress to next stage (skip session, times out)
function nextStage() {
  // Finds the class of the current stage corresponding to its type of stage
  stages[currentStage].classList.forEach(function (i) {
    if (i in stageClasses) {
      //Remove its active stage class
      stages[currentStage].classList.remove(stageClasses[i]);
      return;
    }
  });

  // Increment stage count
  currentStage += 1;

  //Once its at the end reset to beginning
  if (currentStage >= 8) {
    currentStage = 0;
  }

  // Add active stage class to new stage element
  stages[currentStage].classList.forEach(function (i) {
    if (i in stageClasses) {
      stages[currentStage].classList.add(stageClasses[i]);
      currentColor = getComputedStyle(stages[currentStage]).backgroundColor;
      circle.path.setAttribute("stroke", currentColor);
      circle.text.style.color = currentColor;
      return;
    }
  });
}

// Runs when page is loaded
document.addEventListener("DOMContentLoaded", async function () {
  //get current day
  currentDay = new Date().getDay();

  loadTasks();

  // Initlise progress bar element
  circle = new ProgressBar.Circle(timer, {
    color: "green",
    duration: 1000,
    easing: "linear",
    strokeWidth: 9,
    text: {
      value: "Ready to Start",
    },
  });

  circle.set(1);
});
